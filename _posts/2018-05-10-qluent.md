---
layout: post
title: Qluent
description: A fluent queue client for interacting with Azure storage queues
tags: 
- azure-storage-queue
- messaging
- message-queue
- producer-consumer
- azure-storage
- azure
- csharp-library
- netcore2
- netframework
- receive-messages
- message-visibility
- storage-queue
- dequeue
- asynchronous
- message-count
- pop
- message-poison
- serialization
- consumer
- azure-sdk
categories: 
- coding
- .net
published: true
---

***Qluent*** is a ***Fluent Queue Client***

Qluent is simple Fluent API and set of wrapper classes around the Microsoft Azure Storage SDK, allowing you to interact with storage queues using strongly typed objects like in the code snippet below. You can see lots of other ways to use it in the [Documentation on Github][repo-url].

```csharp
var queue = await Builder
    .CreateAQueueOf<Entity>()
    .UsingStorageQueue("my-entity-queue")
    .BuildAsync();
    
await queue.PushAsync(new Entity());
```

### So why did I build this. 

Back in March, some colleagues and I ran into an issue with a legacy project that we'd inherited at work. Specifically, it interacted with and processed messages coming off an azure storage queue. Unfortunately the code responsible for dequeueing, processing and deleting the message was buring in an assembly, the source code for which had long been lost. After much hair pulling and assembly decompilations, we eventually tracked down the bug, but it made me realise a couple of things:

1. Setting up an azure storage queues through the SDK is a little verbose. There's quite a bit of ceremony involved to create an account, client, queue and deal with serialization/deserialization etc.
2. There are some aspects of the SDK I dislike. While I'm sure there were architectural and design reasons for doing so, specifying the large majority of settings on the methods, rather than as configurations on the client itself seems wrong. It leaves lots of sharp corners for the developer to get caught, after they fetch a queue from DI and want to interact with it.
3. There are lots of tricky scenarios to account for even in simple usages, such as accounting for idempotency issues, handling retries and dealing with poison messages.
4. Developers shouldn't need to worry about writing consumers/dispatchers. They should just need to worry about getting their message handled.

### Features

The first thing I wanted to provide was a very simple fluent API for creating a `CloudQueue` or consumer around a `CloudQueue`. Creating a consumer is simply a matter of providing, a type, a queue, a message handler and starting it up.

```csharp
var consumer = Builder
    .CreateAConsumerFor<Entity>()
    .UsingQueue(queue)
    .ThatHandlesMessagesUsing((msg) => 
        { 
            Console.WriteLine($"Processing {msg.Value.Property}"); 
            return true; 
        })
    .Build();

await consumer.Start()
```

The queues themselves supports a number of features that are typical of standard message queueing scenarios

 - Push/Pop/Peek for one or multiple messages
 - Get/Delete operations for receipted removal of one or multiple messages
 - Purging a queue
 - Getting a count of messages on a queue

Queues can also be configured to support

 - Delayed visibility of messages
 - Message TTLs
 - Visibility timeouts for dequeue events
 - Automatic rerouting of poison messages after a number of dequeue & deserialize attempts
 - Customized object serialization

Finally, the message consumer provides a simple way to asynchronously poll a queue including. It supports

 - Message Handlers
 - Failed Processing Handlers (Fallback)
 - Exception Handlers
 - Flow control for when exceptions occur (Exit or Continue)
 - Custom Queue Polling Policies
 - Integration with NLog for Logging
 
A big health warning! This is deliberately and intentionally meant to simplify things. Often times I'll find myself having to scaffold something and spending way too long focusing on the infrastructure code to support message queuing when I should be focusing on the actual problem I'm trying to solve. That's what this is for. It is a simple wrapper around Azure storage queues to make working with them a little easier.

But, this is not an Enterprise Service Bus. There are lots of complicated things you may find yourself doing in a  distributed environment. Complex Retry Policies; complicated routing paths; Pub/Sub models involving topics and queues; the list goes on.

If you find yourself needing to do something complex like this, then perhaps you should be looking at a different technology stack (Azure Service Bus, Event Hubs, Event Grid, Kafka, NService Bus, Mulesoft etc...)

### Get It on Nuget

If you want to try it out, you can [get it on nuget][nuget-stable-url]

[![Nuget Stable][nuget-stable-badge]][nuget-stable-url]

[repo-url]: https://github.com/eoincampbell/Qluent/blob/master/README.md#documentation
[ceremony]: https://github.com/eoincampbell/Qluent/blob/master/README.md#why-do-i-need-this
[nuget-stable-badge]: https://img.shields.io/badge/nuget--stable-1.0.0.35-blue.svg
[nuget-stable-url]: https://www.nuget.org/packages/Qluent/