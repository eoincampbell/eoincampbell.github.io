---
layout: post
title: Qluent
description: A fluent queue client for interacting with Azure storage queues
tags: 
- azure-storage-queue
- messaging
- message-queue
- producer-consumer
- azure-storage
- azure
- csharp-library
- netcore2
- netframework
- receive-messages
- message-visibility
- storage-queue
- dequeue
- asynchronous
- message-count
- pop
- message-poison
- serialization
- consumer
- azure-sdk
categories: 
- coding
- .net
published: false
---

***Qluent*** is a ***Fluent Queue Client***

Qluent is simple Fluent API and set of wrapper classes around the Microsoft Azure Storage SDK, allowing you to interact with storage queues using strongly typed objects like in the code snippet below. You can see lots of other ways to use it in the [Documentation on Github][repo-url].

```csharp
var queue = await Builder
    .CreateAQueueOf<Entity>()
    .UsingStorageQueue("my-entity-queue")
    .BuildAsync();
    
await queue.PushAsync(new Entity());
```

### So why did I build this. 

Back in March, some colleagues and I ran into an issue with a legacy project that we'd inherited at work. Specifically, it interacted with and processed messages coming off an azure storage queue. Unfortunately the code responsible for dequeueing, processing and deleting the message was buring in an assembly, the source code for which had long been lost. After much hair pulling and assembly decompilations, we eventually tracked down the bug, but it made me realise a couple of things:

1. Setting up an azure storage queues through the SDK is a little verbose. There's quite a bit of ceremony involved to create an account, client, queue and deal with serialization/deserialization etc.
2. There are some aspects of the SDK I dislike. While I'm sure there were architectural and design reasons for doing so, specifying the large majority of settings on the methods, rather than as configurations on the client itself seems wrong. It leaves lots of sharp corners for the developer to get caught, after they fetch a queue from DI and want to interact with it.
3. There are lots of tricky scenarios to account for even in simple usages, such as accounting for idempotency issues, handling retries and dealing with poison messages.
4. Developers shouldn't need to worry about writing consumers/dispatchers. They should just need to worry about getting their message handled.

### Features

The first thing I wanted to provide was a very simple fluent API for creating a `CloudQueue` or consumer around a `CloudQueue`. Creating a consumer is simply a matter of providing, a type, a queue, a message handler and starting it up.

```csharp
var consumer = Builder
    .CreateAConsumerFor<Entity>()
    .UsingQueue(queue)
    .ThatHandlesMessagesUsing((msg) => 
        { 
            Console.WriteLine($"Processing {msg.Value.Property}"); 
            return true; 
        })
    .Build();

await consumer.Start()
```

### Features



### Caveats




[repo-url]: https://github.com/eoincampbell/Qluent/blob/master/README.md#documentation
[ceremony]: https://github.com/eoincampbell/Qluent/blob/master/README.md#why-do-i-need-this